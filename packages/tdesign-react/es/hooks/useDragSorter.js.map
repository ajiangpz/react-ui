{"version":3,"file":"useDragSorter.js","sources":["../../../components/hooks/useEventCallback.ts","../../../components/hooks/useDragSorter.tsx"],"sourcesContent":["// https://github.com/scottrippey/react-use-event-hook/blob/75ba34af9175dc311afb3fb302d6fea44e4a5203/src/useEvent.ts\n// [RFC](https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md)\nimport React from 'react';\nimport noop from '../utils/noop';\n\ntype AnyFunction = (...args: unknown[]) => unknown;\n\n/**\n * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)\n * Make use of useInsertionEffect if available.\n */\nconst useInsertionEffect =\n  typeof window !== 'undefined'\n    ? React.useInsertionEffect || React.useLayoutEffect\n    : noop;\n\n/**\n * Render methods should be pure, especially when concurrency is used,\n * so we will throw this error if the callback is called while rendering.\n */\nfunction useEventCallbackShouldNotBeInvokedBeforeMount() {\n  throw new Error(\n    'INVALID_USEEVENTCALLBACK_INVOCATION: the callback from useEventCallback cannot be invoked before the component has mounted.',\n  );\n}\n\n/**\n * Similar to useCallback, with a few subtle differences:\n * - The returned function is a stable reference, and will always be the same between renders\n * - No dependency lists required\n * - Properties or state accessed within the callback will always be \"current\"\n */\nexport default function useEventCallback<TCallback extends AnyFunction>(\n  callback: TCallback,\n): TCallback {\n  // Keep track of the latest callback:\n  const latestRef = React.useRef<TCallback>(\n    useEventCallbackShouldNotBeInvokedBeforeMount as any,\n  );\n  useInsertionEffect(() => {\n    latestRef.current = callback;\n  }, [callback]);\n\n  // Create a stable callback that always calls the latest callback:\n  // using useRef instead of useCallback avoids creating and empty array on every render\n  const stableRef = React.useRef<TCallback>(null as any);\n  if (!stableRef.current) {\n    stableRef.current = function (this: unknown, ...args: unknown[]) {\n      return latestRef.current.apply(this, args);\n    } as TCallback;\n  }\n\n  return stableRef.current;\n}\n","import { useCallback, useState } from 'react';\nimport useEventCallback from './useEventCallback';\n\ninterface DragSortProps<T> {\n  sortOnDraggable: boolean;\n  onDragSort?: (context: DragSortContext<T>) => void;\n  onDragOverCheck?: {\n    x?: boolean;\n    targetClassNameRegExp?: RegExp;\n  };\n}\n\ntype DragFnType = (\n  e?: React.DragEvent<HTMLTableRowElement>,\n  index?: number,\n  record?: any,\n) => void;\ninterface DragSortInnerData {\n  dragging?: boolean;\n  draggable?: boolean;\n  onDragStart?: DragFnType;\n  onDragOver?: DragFnType;\n  onDrop?: DragFnType;\n  onDragEnd?: DragFnType;\n}\n\nexport interface DragSortInnerProps extends DragSortInnerData {\n  getDragProps?: (index?: number, record?: any) => DragSortInnerData;\n}\n\nexport interface DragSortContext<T> {\n  currentIndex: number;\n  current: T;\n  targetIndex: number;\n  target: T;\n}\n\nfunction useDragSorter<T>(props: DragSortProps<T>): DragSortInnerProps {\n  const { sortOnDraggable, onDragSort, onDragOverCheck } = props;\n  const [draggingIndex, setDraggingIndex] = useState(-1);\n  const [dragStartData, setDragStartData] = useState(null);\n  const [isDropped, setIsDropped] = useState(null);\n  const [startInfo, setStartInfo] = useState({\n    nodeX: 0,\n    nodeWidth: 0,\n    mouseX: 0,\n  });\n  const onDragSortEvent = useEventCallback(onDragSort as any);\n\n  const onDragOver = useCallback(\n    (e, index, record: T) => {\n      e.preventDefault();\n      if (draggingIndex === index || draggingIndex === -1) return;\n      if (\n        onDragOverCheck?.targetClassNameRegExp &&\n        !onDragOverCheck?.targetClassNameRegExp.test(e.target?.className)\n      ) {\n        return;\n      }\n\n      if (onDragOverCheck?.x) {\n        if (!startInfo.nodeWidth) return;\n\n        const { x, width } = e.target.getBoundingClientRect();\n        const targetNodeMiddleX = x + width / 2;\n        const clientX = e.clientX || 0;\n        const draggingNodeLeft = clientX - (startInfo.mouseX - startInfo.nodeX);\n        const draggingNodeRight = draggingNodeLeft + startInfo.nodeWidth;\n\n        let overlap = false;\n        if (draggingNodeLeft > x && draggingNodeLeft < x + width) {\n          overlap = draggingNodeLeft < targetNodeMiddleX;\n        } else {\n          overlap = draggingNodeRight > targetNodeMiddleX;\n        }\n        if (!overlap) return;\n      }\n\n      onDragSortEvent({\n        currentIndex: draggingIndex,\n        current: dragStartData,\n        target: record,\n        targetIndex: index,\n      });\n      setDraggingIndex(index);\n    },\n    [\n      draggingIndex,\n      onDragOverCheck?.targetClassNameRegExp,\n      onDragOverCheck?.x,\n      dragStartData,\n      startInfo.nodeWidth,\n      startInfo.mouseX,\n      startInfo.nodeX,\n      onDragSortEvent,\n    ],\n  );\n\n  if (!sortOnDraggable) {\n    return {};\n  }\n\n  function onDragStart(e, index, record: T) {\n    setDraggingIndex(index);\n    setDragStartData(record);\n    if (onDragOverCheck) {\n      const { x, width } = e.target.getBoundingClientRect();\n      setStartInfo({\n        nodeX: x,\n        nodeWidth: width,\n        mouseX: e.clientX || 0,\n      });\n    }\n  }\n\n  function onDrop() {\n    setIsDropped(true);\n  }\n  function onDragEnd() {\n    if (!isDropped) {\n      // 取消排序，待扩展 api，输出 dragStartData\n    }\n    setIsDropped(false);\n    setDraggingIndex(-1);\n    setDragStartData(null);\n  }\n  function getDragProps(index, record: T) {\n    if (sortOnDraggable) {\n      return {\n        draggable: true,\n        onDragStart: (e) => {\n          onDragStart(e, index, record);\n        },\n        onDragOver: (e) => {\n          onDragOver(e, index, record);\n        },\n        onDrop: () => {\n          onDrop();\n        },\n        onDragEnd: () => {\n          onDragEnd();\n        },\n      };\n    }\n    return {};\n  }\n\n  return {\n    onDragStart,\n    onDragOver,\n    onDrop,\n    onDragEnd,\n    getDragProps,\n    dragging: draggingIndex !== -1,\n  };\n}\n\nexport default useDragSorter;\n"],"names":["useInsertionEffect","window","React","useLayoutEffect","noop","useEventCallbackShouldNotBeInvokedBeforeMount","Error","useEventCallback","callback","latestRef","useRef","current","stableRef","_len","arguments","length","args","Array","_key","apply","useDragSorter","props","sortOnDraggable","onDragSort","onDragOverCheck","_useState","useState","_useState2","_slicedToArray","draggingIndex","setDraggingIndex","_useState3","_useState4","dragStartData","setDragStartData","_useState5","_useState6","isDropped","setIsDropped","_useState7","nodeX","nodeWidth","mouseX","_useState8","startInfo","setStartInfo","onDragSortEvent","onDragOver","useCallback","e","index","record","_e$target","preventDefault","targetClassNameRegExp","test","target","className","x","_e$target$getBounding","getBoundingClientRect","width","targetNodeMiddleX","clientX","draggingNodeLeft","draggingNodeRight","overlap","currentIndex","targetIndex","onDragStart","_e$target$getBounding2","onDrop","onDragEnd","getDragProps","draggable","dragging"],"mappings":"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"}