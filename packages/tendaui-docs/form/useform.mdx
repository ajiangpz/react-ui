

## 一、核心问题：时序冲突

### 场景重现

```tsx
// 用户代码
function MyPage() {
  const [form] = Form.useForm();
  
  // ❌ 问题：这里 form 已经存在，但 Form 组件还没渲染
  useEffect(() => {
    form.setFieldsValue({ name: 'John' });  // 此时方法还没注入！
  }, []);
  
  return <Form form={form}>...</Form>;  // Form 组件才开始挂载
}
```

**矛盾点**：
1. `useForm()` 必须立即返回 `form` 实例（用户要用）
2. 但真正的方法实现要等 `<Form>` 组件挂载后才能创建（需要访问 DOM、refs 等）

---

## 二、解决方案：任务队列 + 延迟执行

### 设计思路（类比外卖系统）

```
用户下单（调用方法） → 订单暂存（任务队列） → 餐厅开门（Form挂载） → 执行订单（flashQueue）
```

### 三个阶段

#### 阶段 1：返回"占位实例"（Form 挂载前）

```ts
public getForm = (): InternalFormInstance => ({
  submit: (...args) => {
    this.taskQueue.push({ args, name: "submit" });  // 只记录，不执行
  },
  reset: (...args) => {
    this.taskQueue.push({ args, name: "reset" });
  },
  // ... 其他方法都是占位
  getFieldValue: null,  // 暂时为 null
  _init: true,  // 标记：我还是初始状态
});
```

**此时调用 `form.submit()`**：
- ✅ 不会报错（方法存在）
- ✅ 任务被记录到队列
- ❌ 但不会真正执行（因为 Form 还没挂载）

---

#### 阶段 2：注入真实方法（Form 挂载时）

```tsx
// Form.tsx 组件内部
const formInstance = useInstance(props, formRef, formMapRef, floatingFormDataRef);
// ↑ 这里创建真正的方法实现（可以访问 DOM、refs 等）

Object.assign(form, { ...formInstance });  // 用真实方法覆盖占位方法
form?.getInternalHooks?.(HOOK_MARK)?.setForm?.(formInstance);
```

**`setForm` 做了什么**：

```ts
setForm: (formInstance) => {
  Object.keys(formInstance).forEach((key) => {
    this[key] = formInstance[key];  // 把真实方法注入到 FormStore 实例
  });
}
```

**此时 `form` 的状态**：
- `form.submit` → 真正的提交逻辑
- `form.getFieldValue` → 真正的取值逻辑
- `this.taskQueue` → 还保存着之前的调用记录

---

#### 阶段 3：补偿执行（清空队列）

```ts
React.useEffect(() => {
  form?.getInternalHooks?.(HOOK_MARK)?.flashQueue?.();
  // ↑ 执行之前积压的任务
}, [form]);
```

**`flashQueue` 做了什么**：

```ts
public flashQueue = () => {
  this.taskQueue.forEach((task) => {
    this[task.name].apply(this, [...task.args]);
    // ↑ 现在 this[task.name] 已经是真实方法了！
  });
  this.taskQueue = [];  // 清空队列
};
```

---

## 三、完整流程图解

```
时间线：
┌─────────────────────────────────────────────────────────────┐
│ 1. useForm() 被调用                                          │
│    → 创建 FormStore                                          │
│    → 返回占位实例 [form]                                      │
│    → form.submit/reset 等都是"记录函数"                       │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 用户可能提前调用方法                                       │
│    form.setFieldsValue({ name: 'John' })                    │
│    → 任务被推入 taskQueue                                     │
│    → taskQueue = [{ name: 'setFieldsValue', args: [...] }]  │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. <Form> 组件开始渲染                                        │
│    → useInstance 创建真实方法                                 │
│    → Object.assign(form, formInstance)  // 覆盖占位方法       │
│    → setForm(formInstance)  // 注入到 FormStore              │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. useEffect 触发                                            │
│    → flashQueue() 执行                                       │
│    → 遍历 taskQueue，用真实方法重新执行                       │
│    → this['setFieldsValue'].apply(this, args)               │
│    → 清空队列                                                 │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 之后的调用直接执行                                         │
│    form.submit() → 直接调用真实方法                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 四、关键代码逐行解读

### 1. 构造函数

```ts
constructor(forceReRender) {
  this.forceRootUpdate = forceReRender;
  // ↑ 保存强制刷新函数（虽然当前实现为空，但预留了强制更新的能力）
}
```

---

### 2. 任务队列

```ts
public taskQueue: { name: string; args: unknown[] }[] = [];
// ↑ 存储格式：[{ name: '方法名', args: [参数1, 参数2, ...] }]

// 例如：
// taskQueue = [
//   { name: 'setFieldsValue', args: [{ name: 'John' }] },
//   { name: 'submit', args: [] }
// ]
```

---

### 3. 内部钩子（安全门）

```ts
private getInternalHooks = (key: string): InternalHooks | null => {
  if (key === HOOK_MARK) {  // HOOK_MARK = "TD_FORM_INTERNAL_HOOKS"
    return {
      setForm: ...,      // 注入真实方法
      flashQueue: ...,   // 清空队列
      notifyWatch: ...,  // 通知观察者
      registerWatch: ...,// 注册观察者
      getPrevStore: ..., // 获取上次数据
      setPrevStore: ..., // 保存上次数据
    };
  }
  console.warn("不允许外部调用");  // 防止用户误用
  return null;
};
```

**为什么需要密钥**？
- 这些方法是内部 API，不应该暴露给用户
- 只有 Form 组件内部知道 `HOOK_MARK`，才能访问

---

### 4. 观察者模式（Watch）

```ts
private watchList: WatchCallBack[] = [];  // 订阅者列表

// 注册订阅
private registerWatch = (callback) => {
  this.watchList.push(callback);
  return () => {
    this.watchList = this.watchList.filter(fn => fn !== callback);  // 返回取消订阅函数
  };
};

// 通知所有订阅者
private notifyWatch = (namePath = []) => {
  if (this.watchList.length) {
    const values = this.getFieldsValue?.([namePath]);  // 获取最新值
    this.watchList.forEach((callback) => {
      callback(values, namePath);  // 通知每个订阅者
    });
  }
};
```

**使用场景**：

```tsx
// 用户代码
const name = Form.useWatch('name', form);  // 订阅 name 字段
// ↑ 内部调用 registerWatch，当 name 变化时自动更新
```

---

### 5. useState 的妙用

```ts
const [formInstance, setFormInstance] = useState<InternalFormInstance>(() => {
  if (form) {
    return form;  // 外部传入，直接用
  }
  const formStore = new FormStore(forceReRender);
  return formStore.getForm();  // 内部创建
});

// 支持外部 form 动态变化
if (form && formInstance !== form) {
  setFormInstance(form);
}
```

**两种用法**：

```tsx
// 用法 1：内部自动创建
const [form] = Form.useForm();

// 用法 2：外部提前创建（多表单联动）
const [form] = Form.useForm();
<Form form={form}>...</Form>
<AnotherForm form={form}>...</AnotherForm>  // 共享同一个实例
```

---

## 五、类比理解

### 类比 1：餐厅点餐系统

| 阶段 | 表单系统 | 餐厅系统 |
|------|---------|---------|
| 1. 创建实例 | `useForm()` | 拿到点餐 APP |
| 2. 提前调用 | `form.submit()` | 下单（餐厅还没开门） |
| 3. 任务队列 | `taskQueue.push()` | 订单暂存在系统 |
| 4. 组件挂载 | `<Form>` 渲染 | 餐厅开门 |
| 5. 注入方法 | `setForm()` | 厨师就位 |
| 6. 执行队列 | `flashQueue()` | 处理积压订单 |
| 7. 后续调用 | 直接执行 | 正常点餐 |

---

### 类比 2：快递代收点

```
用户寄件（调用方法） → 快递还没来（Form未挂载） → 暂存代收点（taskQueue）
→ 快递员到达（Form挂载） → 批量发货（flashQueue）
```

---

## 六、为什么要这么设计？

### 问题：为什么不等 Form 挂载后再返回 form？

```tsx
// ❌ 这样不行
function MyPage() {
  const [form] = Form.useForm();
  
  if (!form) return null;  // 第一次渲染 form 为空？
  
  return <Form form={form}>...</Form>;
}
```

**原因**：
- React Hooks 必须在组件顶层同步执行
- 不能条件返回（违反 Hooks 规则）
- 用户期望立即拿到 `form` 实例

---

### 问题：为什么不直接在 useForm 里实现所有方法？

```tsx
// ❌ 这样不行
function useForm() {
  return {
    submit: () => { /* 提交逻辑 */ },
    reset: () => { /* 重置逻辑 */ }
  };
}
```

**原因**：
- 这些方法需要访问 `formRef`、`formMapRef` 等（只有 Form 组件才有）
- 需要访问 DOM 节点（滚动到错误、聚焦等）
- 需要访问 props（`onSubmit`、`rules` 等）

---

## 七、总结

### 核心逻辑三步走

1. **占位阶段**：返回"假方法"，调用时只记录不执行
2. **注入阶段**：Form 挂载后，用真方法替换假方法
3. **补偿阶段**：执行之前积压的任务

### 设计模式

- **代理模式**：占位方法是真实方法的代理
- **命令模式**：任务队列存储命令，延迟执行
- **观察者模式**：Watch 机制监听字段变化

### 类比记忆

> **useForm 就像一个"期货合约"**：
> - 先给你一个"提货券"（form 实例）
> - 你可以提前"下单"（调用方法）
> - 等"货物到达"（Form 挂载）后统一"发货"（执行任务）

---
