

## `floatingFormDataRef` 游离值的作用

这是一个**临时数据缓冲区**，用于解决**"FormItem 还未渲染，但数据已经需要设置"**的时序问题。

---

## 一、核心问题：时序错配

### 问题场景

```tsx
const [form] = Form.useForm();

// 场景 1：FormItem 还未渲染就设置值
useEffect(() => {
  form.setFieldsValue({ name: 'John', age: 18 });
  // ❌ 此时 <FormItem name="name"> 可能还没挂载！
}, []);

return (
  <Form form={form}>
    <FormItem name="name">
      <Input />
    </FormItem>
  </Form>
);
```

```tsx
// 场景 2：动态表单 - 添加新项时预设值
<FormList name="users">
  {(fields, { add }) => (
    <>
      {fields.map((field, index) => (
        <FormItem name={[index, 'name']}>
          <Input />
        </FormItem>
      ))}
      <Button onClick={() => add({ name: 'New User', age: 25 })}>
        {/* ↑ 新 FormItem 还没渲染，但数据已经准备好了 */}
        添加用户
      </Button>
    </>
  )}
</FormList>
```

**矛盾**：
- 数据先到达（`setFieldsValue` 或 `add` 调用）
- FormItem 后渲染（React 异步渲染）
- 数据无处存放！

---

## 二、解决方案：游离值缓冲区

### 定义

```ts:57:57:packages/components/form/Form.tsx
const floatingFormDataRef = useRef({}); // 储存游离值的 formData
```

**数据结构**：

```ts
floatingFormDataRef.current = {
  name: 'John',           // 单个字段
  age: 18,
  users: [                // 嵌套数组
    { name: 'Alice', age: 20 },
    { name: 'Bob', age: 25 }
  ],
  'address.city': 'Beijing'  // 嵌套对象（路径形式）
}
```

---

## 三、完整流程解析

### 流程 1：写入游离值（setFieldsValue）

```ts:152:178:packages/components/form/hooks/useInstance.tsx
// 对外方法，设置对应 formItem 的值
function setFieldsValue(fields = {}) {
  const nameLists = objectToArray(fields);

  nameLists.forEach((nameList) => {
    const fieldValue = get(fields, nameList);

    let formItemRef;
    if (nameList.length > 1) {
      // 如果是数组，由于内存地址不一致，不能直接使用 Map.get 获取到 formItemRef
      for (const [mapNameList, _formItemRef] of formMapRef.current.entries()) {
        if (isEqual(nameList, mapNameList)) {
          formItemRef = _formItemRef;
          break;
        }
      }
    } else {
      formItemRef = formMapRef.current.get(nameList[0]);
    }

    if (formItemRef?.current) {
      formItemRef?.current?.setValue?.(fieldValue, fields);
    } else {
      set(floatingFormDataRef.current, nameList, fieldValue);
    }
  });
}
```

**关键逻辑**：

```ts
if (formItemRef?.current) {
  // FormItem 已存在 → 直接设置值
  formItemRef?.current?.setValue?.(fieldValue, fields);
} else {
  // FormItem 不存在 → 存入游离值
  set(floatingFormDataRef.current, nameList, fieldValue);
}
```

---

### 流程 2：读取游离值（FormItem 初始化）

```ts:56:66:packages/components/form/hooks/useFormItemInitialData.ts
if (name && floatingFormDataRef?.current && !isEmpty(floatingFormDataRef.current)) {
  const nameList = formListName ? [formListName, name].flat() : name;
  const defaultInitialData = get(floatingFormDataRef.current, nameList);
  if (typeof defaultInitialData !== "undefined") {
    // 使用 setTimeout 来延迟清理，避免在渲染期间修改 ref
    setTimeout(() => {
      unset(floatingFormDataRef.current, nameList);
    }, 0);
    return defaultInitialData;
  }
}
```

**关键逻辑**：

1. FormItem 渲染时，先检查 `floatingFormDataRef`
2. 如果有对应的游离值，取出作为初始值
3. **立即清理**（用 `setTimeout` 延迟到渲染后）
4. 避免影响后续同名 FormItem

---

## 四、典型场景详解

### 场景 1：提前设置表单值（异步数据回填）

```tsx
function EditUser({ userId }) {
  const [form] = Form.useForm();

  useEffect(() => {
    // 1. 异步获取数据
    fetchUser(userId).then(user => {
      // 2. 此时 FormItem 可能还没渲染完
      form.setFieldsValue({
        name: user.name,
        age: user.age,
        email: user.email
      });
      // ↑ 这些值会先存入 floatingFormDataRef
    });
  }, [userId]);

  return (
    <Form form={form}>
      {/* 3. FormItem 渲染时，从 floatingFormDataRef 读取初始值 */}
      <FormItem name="name">
        <Input />
      </FormItem>
      <FormItem name="age">
        <Input />
      </FormItem>
      <FormItem name="email">
        <Input />
      </FormItem>
    </Form>
  );
}
```

**时间线**：

```
T1: useEffect 执行 → setFieldsValue 调用
    → FormItem 还没渲染
    → 数据存入 floatingFormDataRef.current = { name: 'John', age: 18, email: 'john@example.com' }

T2: FormItem 开始渲染
    → useFormItemInitialData 读取 floatingFormDataRef
    → 取出 name: 'John'
    → setTimeout 清理 floatingFormDataRef.current.name

T3: 后续 FormItem 渲染
    → 依次取出 age、email
    → 清理对应字段

T4: floatingFormDataRef.current = {}  // 已清空
```

---

### 场景 2：动态表单添加（FormList.add）

```tsx
<FormList name="contacts">
  {(fields, { add, remove }) => (
    <>
      {fields.map((field, index) => (
        <div key={field.key}>
          <FormItem name={[index, 'phone']}>
            <Input />
          </FormItem>
          <FormItem name={[index, 'email']}>
            <Input />
          </FormItem>
          <Button onClick={() => remove(index)}>删除</Button>
        </div>
      ))}
      
      <Button onClick={() => {
        // 1. 添加新项，并预设初始值
        add({ phone: '13800138000', email: 'new@example.com' });
        // ↑ 新 FormItem 还没渲染，数据先存入 floatingFormDataRef
      }}>
        添加联系人
      </Button>
    </>
  )}
</FormList>
```

**内部实现**（简化版）：

```ts
// FormList 的 add 方法
function add(defaultValue = {}) {
  const newIndex = fields.length;
  
  // 1. 更新 fields 数组（触发重渲染）
  setFields([...fields, { key: newIndex }]);
  
  // 2. 将初始值存入游离值
  Object.keys(defaultValue).forEach(key => {
    const path = [name, newIndex, key];  // ['contacts', 2, 'phone']
    set(floatingFormDataRef.current, path, defaultValue[key]);
  });
  
  // 3. 新 FormItem 渲染时，从 floatingFormDataRef 读取
}
```

---

### 场景 3：条件渲染表单项

```tsx
const [showAdvanced, setShowAdvanced] = useState(false);
const [form] = Form.useForm();

// 提前设置高级选项的值
useEffect(() => {
  form.setFieldsValue({
    basicField: 'value1',
    advancedField: 'value2'  // 但 advancedField 的 FormItem 还没渲染
  });
}, []);

return (
  <Form form={form}>
    <FormItem name="basicField">
      <Input />
    </FormItem>
    
    <Checkbox onChange={e => setShowAdvanced(e.target.checked)}>
      显示高级选项
    </Checkbox>
    
    {showAdvanced && (
      <FormItem name="advancedField">
        {/* 渲染时从 floatingFormDataRef 读取 'value2' */}
        <Input />
      </FormItem>
    )}
  </Form>
);
```

---

## 五、为什么要立即清理？

```ts:60:63:packages/components/form/hooks/useFormItemInitialData.ts
setTimeout(() => {
  unset(floatingFormDataRef.current, nameList);
}, 0);
```

### 原因 1：避免污染后续同名字段

```tsx
<FormList name="users">
  {(fields, { add }) => (
    <>
      <Button onClick={() => add({ name: 'Alice' })}>添加</Button>
      <Button onClick={() => add({ name: 'Bob' })}>添加</Button>
    </>
  )}
</FormList>
```

**如果不清理**：

```
第一次 add({ name: 'Alice' })
  → floatingFormDataRef.current = { users: [{ name: 'Alice' }] }
  → FormItem 读取 'Alice'
  → ❌ 不清理

第二次 add({ name: 'Bob' })
  → floatingFormDataRef.current = { users: [{ name: 'Alice' }, { name: 'Bob' }] }
  → 新 FormItem 可能错误读取到 'Alice'！
```

---

### 原因 2：游离值是一次性的

游离值的语义：**"这是给即将渲染的 FormItem 准备的临时数据"**

- 用完即删
- 不应该持久化
- 避免内存泄漏

---

### 为什么用 `setTimeout`？

```ts
// ❌ 直接清理会报错
unset(floatingFormDataRef.current, nameList);  // 在渲染期间修改 ref

// ✅ 延迟到渲染后清理
setTimeout(() => {
  unset(floatingFormDataRef.current, nameList);
}, 0);
```

**React 规则**：渲染期间不能有副作用（修改 ref 算副作用）

---

## 六、与 `formMapRef` 的对比

| 特性 | `formMapRef` | `floatingFormDataRef` |
|------|-------------|---------------------|
| **存储内容** | FormItem 实例引用 | 临时数据值 |
| **生命周期** | 持久（FormItem 挂载到卸载） | 临时（用完即删） |
| **用途** | 批量操作 FormItem | 数据缓冲 |
| **清理时机** | FormItem 卸载时 | 读取后立即清理 |
| **数据结构** | `Map<NamePath, Ref>` | `Record<string, unknown>` |

**示例**：

```ts
// formMapRef（持久）
formMapRef.current = Map {
  'name' => { current: FormItemInstance },
  'age' => { current: FormItemInstance },
  ['users', 0, 'phone'] => { current: FormItemInstance }
}

// floatingFormDataRef（临时）
floatingFormDataRef.current = {
  name: 'John',  // 读取后立即删除
  age: 18,       // 读取后立即删除
}
```

---

## 七、完整数据流图

```
┌─────────────────────────────────────────────────────────┐
│  用户调用 form.setFieldsValue({ name: 'John' })        │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  setFieldsValue 内部逻辑                                 │
│  1. 查找 formMapRef.current.get('name')                 │
│  2. 如果找到 → 直接 setValue                            │
│  3. 如果没找到 → 存入 floatingFormDataRef               │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  floatingFormDataRef.current = { name: 'John' }         │
│  (临时存储，等待 FormItem 渲染)                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  <FormItem name="name"> 开始渲染                        │
│  → useFormItemInitialData 执行                          │
│  → 检查 floatingFormDataRef.current.name                │
│  → 找到 'John'                                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  1. 返回 'John' 作为初始值                               │
│  2. setTimeout(() => {                                  │
│       delete floatingFormDataRef.current.name           │
│     }, 0)                                               │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  FormItem 渲染完成，值为 'John'                          │
│  floatingFormDataRef.current = {}  // 已清空            │
└─────────────────────────────────────────────────────────┘
```

---

## 八、类比理解

### 类比 1：快递代收点

```
你网购了商品（数据）
  ↓
快递先到了，但你不在家（FormItem 未渲染）
  ↓
快递员把包裹放在代收点（floatingFormDataRef）
  ↓
你回家后去代收点取件（FormItem 渲染时读取）
  ↓
取走后，代收点清空这个位置（清理游离值）
```

---

### 类比 2：餐厅点餐

```
你提前点了外卖（setFieldsValue）
  ↓
餐厅还没开门（FormItem 未渲染）
  ↓
订单暂存在系统（floatingFormDataRef）
  ↓
餐厅开门后，看到订单并制作（FormItem 读取游离值）
  ↓
订单完成后删除（清理游离值）
```

---

## 九、边界情况处理

### 情况 1：游离值被覆盖

```tsx
form.setFieldsValue({ name: 'John' });   // 存入游离值
form.setFieldsValue({ name: 'Alice' });  // 覆盖游离值
// FormItem 渲染时读取到 'Alice'
```

---

### 情况 2：FormItem 先渲染，后设置值

```tsx
return (
  <Form form={form}>
    <FormItem name="name">
      <Input />  {/* 先渲染 */}
    </FormItem>
  </Form>
);

// 后调用
useEffect(() => {
  form.setFieldsValue({ name: 'John' });
  // ✅ FormItem 已存在，直接 setValue，不走游离值
}, []);
```

---

### 情况 3：游离值未被消费

```tsx
form.setFieldsValue({ nonExistField: 'value' });
// 如果始终没有 <FormItem name="nonExistField">
// 游离值会一直留在 floatingFormDataRef 中
// ⚠️ 可能导致内存泄漏（但通常不会，因为表单卸载时会清理）
```

---

## 十、总结

### 核心作用
`floatingFormDataRef` 是一个**临时数据缓冲区**，用于：
1. 解决数据先到、FormItem 后渲染的时序问题
2. 支持动态表单的预设值
3. 支持条件渲染表单项的数据回填

### 设计亮点
- **自动降级**：FormItem 存在时直接设置，不存在时缓冲
- **用完即删**：避免污染后续同名字段
- **延迟清理**：遵守 React 渲染规则
- **无侵入**：用户无需关心，自动处理

### 记忆口诀
> **"游离值是快递代收点，数据先到暂存，FormItem 取走即清"**

### 适用场景
- ✅ 异步数据回填
- ✅ 动态表单添加
- ✅ 条件渲染表单项
- ✅ 提前设置未渲染字段
